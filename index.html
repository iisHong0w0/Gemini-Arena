<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Arena - 多AI對話模擬器</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: #f0f2f5; color: #1c1e21; display: flex; flex-direction: column; min-height: 100vh; line-height: 1.6; }
        header { background-color: #4267B2; color: white; padding: 0.8em 1em; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        .container { display: flex; flex-grow: 1; padding: 1em; gap: 1em; overflow: hidden; }
        .config-panel { width: 340px; flex-shrink: 0; background-color: #fff; padding: 1.5em; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.12); display: flex; flex-direction: column; gap: 1.2em; max-height: calc(100vh - 2em - 50px); overflow-y: auto; }
        .chat-display-panel { flex-grow: 1; min-width: 0; background-color: #fff; padding: 1.5em; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.12); display: flex; flex-direction: column; max-height: calc(100vh - 2em - 50px); }
        .card { background-color: #f7f8fa; padding: 1em; border-radius: 6px; border: 1px solid #dddfe2; }
        h1 {font-size: 1.5em; margin: 0;}
        h2, h3 { color: #4267B2; margin-top: 0; margin-bottom: 0.8em;}
        h3 {font-size: 1.1em;}
        h4 {font-size: 1em; margin-top:0; margin-bottom: 0.5em;}

        label { display: block; margin-bottom: 0.4em; font-weight: 600; color: #4b4f56; font-size: 0.9em; }
        input[type="text"], input[type="password"], input[type="number"], textarea, select { width: 100%; padding: 0.7em; margin-bottom: 0.5em; border: 1px solid #ccd0d5; border-radius: 4px; font-size: 0.95em; box-sizing: border-box; }
        input[type="checkbox"] { width: auto; margin-right: 0.5em; margin-bottom:0; vertical-align: middle; cursor:pointer; }
        textarea { min-height: 60px; resize: vertical; }
        button { background-color: #42b72a; color: white; border: none; padding: 0.8em 1.2em; border-radius: 6px; cursor: pointer; font-size: 0.95em; font-weight: 600; transition: background-color 0.2s; width: 100%; margin-top: 0.5em; }
        button:first-of-type { margin-top: 0; }
        button:hover { background-color: #36a420; }
        button:disabled { background-color: #ccd0d5; color: #8d949e; cursor: not-allowed; }
        button.inline-button { width: auto; font-size: 0.85em; padding: 0.5em 0.8em; margin-left: 5px; vertical-align: middle; margin-top:0;}
        button.small-action-button { width: auto; font-size: 0.85em; padding: 0.5em 0.8em; margin-top: 0.2em;}

        button.secondary { background-color: #1877f2; }
        button.secondary:hover { background-color: #166fe5; }
        button.danger { background-color: #fa383e; }
        button.danger:hover { background-color: #e0282d; }

        .lang-switcher button { background-color: #f0f2f5; color: #4267B2; border: 1px solid #4267B2; padding: 0.4em 0.8em; font-size: 0.8em; margin-left: 5px; width: auto; }
        .lang-switcher button.active { background-color: #4267B2; color: white; }


        #aiAgentsConfigContainer .ai-config-card { border: 1px solid #ddd; padding: 1em; margin-bottom: 1em; border-radius: 5px; background: #f9f9f9; }
        #conversationLog { flex-grow: 1; overflow-y: auto; border: 1px solid #dddfe2; padding: 1em; background-color: #e9ebee; border-radius: 6px; margin-top:1em;}
        .chat-turn { margin-bottom: 1em; padding: 0.8em 1em; border-radius: 12px; max-width: 85%; word-wrap: break-word; }
        .ai-turn { background-color: #e7f3ff; border-left: 4px solid #1877f2; margin-right: auto; }
        .user-turn { background-color: #d5f0d9; border-left: 4px solid #42b72a; margin-left: auto; text-align: left; } /* System/User messages */
        .chat-turn .sender { font-weight: bold; display: block; margin-bottom: 0.4em; font-size: 0.9em; }
        .chat-turn .message-content { font-size: 0.95em; white-space: pre-wrap; } /* Added pre-wrap for newlines */
        .loading-indicator { display: none; text-align: center; padding: 1em; }
        .warning { background-color: #fffbe2; color: #5c4d00; padding: 1em; border-radius: 4px; border: 1px solid #fff0b3; margin-bottom: 1em; font-size: 0.85em;}
        #userInputSection { margin-top:1em; padding-top:1em; border-top: 1px solid #dddfe2;}
        #userInputSection button { width: auto; padding: 0.7em 1em; font-size: 0.9em; }

        .input-group { display: flex; align-items: center; margin-bottom: 0.5em;}
        .input-group input { flex-grow: 1; margin-bottom: 0;}
        .input-group button { margin-left: 0.5em; margin-top:0; flex-shrink:0; }


        @media (max-width: 768px) {
            header { flex-direction: column; gap: 0.5em; padding-bottom: 0.5em;}
            .lang-switcher { margin-top: 0.3em; }
            .container { flex-direction: column; padding: 0.5em; overflow-y: auto; }
            .config-panel, .chat-display-panel { width: 100%; box-sizing: border-box; max-height: none; margin-bottom: 1em; }
            .config-panel { order: 1; max-height: 70vh; overflow-y: auto; }
            .chat-display-panel { order: 2; min-height: 300px; }
            h1 {font-size: 1.3em;}
            button {font-size: 0.9em; padding: 0.9em;}
            .chat-turn { max-width: 95%; }
        }
    </style>
</head>
<body>
    <header>
        <h1 id="headerTitle">Gemini Arena</h1>
        <div class="lang-switcher">
            <button id="langEnBtn">English</button>
            <button id="langZhBtn">中文</button>
        </div>
    </header>

    <div class="container">
        <aside class="config-panel">
            <div class="card">
                <h3 id="apiKeyCardTitle"><span style="color:red; font-weight:bold;">重要</span>: API 金鑰</h3>
                <div class="input-group">
                    <input type="password" id="apiKey" placeholder="在此輸入您的 API 金鑰">
                    <button id="getApiKeyBtn" class="inline-button secondary" title="如何獲取 Gemini API 金鑰">獲取金鑰</button>
                </div>
                <small id="apiKeyNote" style="color:red; display:block; margin-bottom:5px; font-size:0.8em;">此金鑰僅儲存在瀏覽器中。</small>
            </div>

            <div class="card">
                <h3 id="conversationSettingsTitle">對話設定</h3>
                <label for="numAIs" id="numAIsLabel">AI 參與者數量 (2-5):</label>
                <input type="number" id="numAIs" value="2" min="2" max="5">

                <label for="conversationTopic" id="conversationTopicLabel">對話主題 (可選):</label>
                <textarea id="conversationTopic" placeholder="例如：AI的道德倫理"></textarea>

                <label for="maxTurns" id="maxTurnsLabel">最大對話輪次 (每AI發言一次算一輪):</label>
                <input type="number" id="maxTurns" value="5" min="1" max="20">

                <label for="rateLimit" id="rateLimitLabel">每分鐘最大對話數 (AI發言次數):</label>
                <input type="number" id="rateLimit" value="5" min="1" max="60">

                <div style="margin-top: 0.8em; padding-top: 0.8em; border-top: 1px solid #eee;">
                    <label for="autoNextTurnCheckbox" id="autoNextTurnLabel" style="display: flex; align-items: center; font-weight: normal; margin-bottom:0; cursor:pointer;">
                        <input type="checkbox" id="autoNextTurnCheckbox">
                        <span id="autoNextTurnText">自動進行下一輪</span>
                    </label>
                    <small id="autoNextTurnNote" style="font-size:0.8em; color: #555; display:block; margin-left: 1.9em;">啟用後，AI 將自動輪流發言。</small>
                </div>
            </div>

            <div class="card">
                <h3 id="modelManagementTitle">模型管理(可選)</h3>
                <label for="customModelName" id="customModelNameLabel">添加自定義模型名稱(本身自帶模型)</label>
                <div class="input-group">
                    <input type="text" id="customModelName" placeholder="例如：gemini-1.5-flash">
                    <button id="addCustomModelBtn" class="small-action-button">添加</button>
                </div>
                 <small id="customModelNote" style="font-size:0.8em; color: #555;">添加後，模型將出現在下方AI配置的下拉選單中。</small>
            </div>


            <div id="aiAgentsConfigContainer">
                <h3 id="aiParticipantsConfigTitle">AI 參與者配置</h3>
                <!-- AI agent configurations will be added here by JS -->
            </div>

            <button id="startConversationBtn">開始對話</button>
            <button id="nextTurnBtn" style="display:none;" class="secondary">下一位 AI 發言</button>
            <button id="stopConversationBtn" class="danger" style="display:none;">終止對話</button>
            <button id="exportLogBtn" style="display:none;">導出對話記錄</button>
        </aside>

        <main class="chat-display-panel">
            <h2 id="conversationLogTitle">對話記錄</h2>
            <div class="warning">
                <strong id="warningTipTitle">提示：</strong>
                <ul>
                    <li id="warningLi1">API 金鑰僅儲存在您目前的瀏覽器會話中。</li>
                    <li id="warningLi2">預覽版/自定義模型名稱可能變更或不可用，請確認。</li>
                    <li id="warningLi3">直接從瀏覽器呼叫 Google API <strong>極有可能會遇到 CORS 問題</strong>。請檢查瀏覽器控制台。</li>
                </ul>
            </div>
            <div id="conversationLog">
                <p id="conversationNotStarted"><em>對話尚未開始... 請在左側配置並開始。</em></p>
            </div>
            <div class="loading-indicator" id="loadingIndicator">
                <p id="loadingText">AI 正在思考中...</p>
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Loading..." width="40">
            </div>
             <div id="userInputSection" style="display:none;">
                <label for="userInjectMessage" id="userInjectMessageLabel">你的發言/提問:</label>
                <textarea id="userInjectMessage" placeholder="在此輸入你想對 AI 們說的話..."></textarea>
                <button id="sendUserMessageBtn" class="secondary">發送給所有AI</button>
            </div>
        </main>
    </div>

    <script>
        // DOM Elements
        const apiKeyInput = document.getElementById('apiKey');
        const getApiKeyBtn = document.getElementById('getApiKeyBtn');
        const numAIsInput = document.getElementById('numAIs');
        const conversationTopicInput = document.getElementById('conversationTopic');
        const maxTurnsInput = document.getElementById('maxTurns');
        const rateLimitInput = document.getElementById('rateLimit');
        const autoNextTurnCheckbox = document.getElementById('autoNextTurnCheckbox');
        const customModelNameInput = document.getElementById('customModelName');
        const addCustomModelBtn = document.getElementById('addCustomModelBtn');
        const aiAgentsConfigContainer = document.getElementById('aiAgentsConfigContainer');
        const startConversationBtn = document.getElementById('startConversationBtn');
        const nextTurnBtn = document.getElementById('nextTurnBtn');
        const stopConversationBtn = document.getElementById('stopConversationBtn');
        const exportLogBtn = document.getElementById('exportLogBtn');
        const conversationLogDiv = document.getElementById('conversationLog');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const userInputSection = document.getElementById('userInputSection');
        const userInjectMessageInput = document.getElementById('userInjectMessage');
        const sendUserMessageBtn = document.getElementById('sendUserMessageBtn');
        const langEnBtn = document.getElementById('langEnBtn');
        const langZhBtn = document.getElementById('langZhBtn');

        // Global Variables
        let GEMINI_API_KEY = '';
        let conversationActive = false;
        let currentTurn = 0;
        let currentAIIndex = 0;
        let currentMaxTurns = 5;
        let agents = [];
        let fullConversationHistory = [];
        let abortController = null;
        let apiCallTimestamps = [];
        let currentRateLimit = 5;
        let currentLanguage = 'zh'; // Default language

        const translations = {
            en: {
                pageTitle: "Gemini Arena - Multi-AI Conversation Simulator",
                headerTitle: "Gemini Arena",
                apiKeyCardTitle: "<span style='color:red; font-weight:bold;'>IMPORTANT</span>: API Key",
                apiKeyPlaceholder: "Enter your API Key here",
                getApiKeyBtn: "Get Key",
                getApiKeyBtnTitle: "How to get a Gemini API Key",
                apiKeyNote: "This key is only stored in your browser.",
                conversationSettingsTitle: "Conversation Settings",
                numAIsLabel: "Number of AI Participants (2-5):",
                conversationTopicLabel: "Conversation Topic (Optional):",
                conversationTopicPlaceholder: "e.g., Ethical implications of AI",
                maxTurnsLabel: "Max Conversation Turns (one turn per AI speech):",
                rateLimitLabel: "Max API Calls per Minute (AI speeches):",
                autoNextTurnText: "Auto next turn",
                autoNextTurnNote: "If enabled, AIs will take turns automatically.",
                modelManagementTitle: "Model Management (Optional)",
                customModelNameLabel: "Add Custom Model Name (built-in models available)",
                customModelNamePlaceholder: "e.g., gemini-1.5-pro",
                addCustomModelBtn: "Add",
                customModelNote: "After adding, the model will appear in the AI config dropdowns below.",
                aiParticipantsConfigTitle: "AI Participant Configuration",
                aiCardTitle: "AI",
                aiNameLabel: "Name:",
                aiModelLabel: "Model:",
                aiPersonaLabel: "Persona/Style Prompt (Optional):",
                aiPersonaPlaceholder: "e.g., You are a seasoned philosopher...",
                aiDefaultName: "AI",
                startConversationBtn: "Start Conversation",
                nextTurnBtn: "Next AI Speaks",
                stopConversationBtn: "Stop Conversation",
                exportLogBtn: "Export Log",
                conversationLogTitle: "Conversation Log",
                warningTipTitle: "Tip:",
                warningLi1: "API Key is only stored in your current browser session.",
                warningLi2: "Preview/custom model names might change or be unavailable. Please verify.",
                warningLi3: "Calling Google API directly from the browser is <strong>highly likely to encounter CORS issues</strong>. Check browser console.",
                conversationNotStarted: "<em>Conversation not started... Please configure and start on the left.</em>",
                loadingText: "AI is thinking...",
                rateLimitWaitingText: "Rate limit reached. Waiting {seconds} seconds...",
                userInjectMessageLabel: "Your Speech/Question:",
                userInjectMessagePlaceholder: "Enter what you want to say to the AIs...",
                sendUserMessageBtn: "Send to all AIs",
                systemLogPrefix: "System",
                observerLogPrefix: "You (Observer)",
                errorApiKeyNotSet: "Error: API Key not set.",
                errorApiFailure: "API request failed ({modelName}): {status} - {message}",
                errorApiFailureNoMsg: "API request failed ({modelName}): {status}",
                errorApiKeyInvalid: " Please check your API key.",
                errorModelNotFound: " Model \"{modelName}\" might not exist, be unavailable, or you lack permission. Please verify the model name.",
                errorRateLimit: " Request frequency limit.",
                errorResponseBlocked: "API response content blocked ({modelName}): {reason}. {reasonMessage}",
                errorResponseInvalid: "API response format unrecognized or empty ({modelName}).",
                errorApiCall: "Error calling API ({modelName}): {message}. Check browser console (could be CORS issue).",
                errorRequestAborted: "API request aborted by user.",
                logConversationStarted: "Conversation started! Topic: {topic}. {numAIs} AIs, max {maxTurns} turns. Max {rateLimit} AI speeches/min. Auto-speak mode: {autoModeStatus}.",
                logTopicFree: "Free talk",
                logAutoModeOn: "ON",
                logAutoModeOff: "OFF",
                logMaxTurnsReached: "Maximum conversation turns reached.",
                logConversationStopped: "Conversation stopped.",
                logCustomModelAdded: "Custom model \"{modelName}\" added.",
                alertEnterModelName: "Please enter a valid model name.",
                alertModelExists: "Model \"{modelName}\" already exists in the list.",
                logAiFailedToSpeak: "{agentName} failed to speak.",
                logAutoRetryNextAi: "Automatically trying next AI...",
                logRateLimitWait: "Reached {rateLimit} calls per minute limit. Will continue in {seconds} seconds...",
                modelFlashPreviewName: "Gemini 2.5 Flash Preview (04-17)",
                modelFlashName: "Gemini 2.0 Flash",
                modelCustomSuffix: "(Custom)"
            },
            zh: {
                pageTitle: "Gemini Arena - 多AI對話模擬器",
                headerTitle: "Gemini Arena",
                apiKeyCardTitle: "<span style='color:red; font-weight:bold;'>重要</span>: API 金鑰",
                apiKeyPlaceholder: "在此輸入您的 API 金鑰",
                getApiKeyBtn: "獲取金鑰",
                getApiKeyBtnTitle: "如何獲取 Gemini API 金鑰",
                apiKeyNote: "此金鑰僅儲存在瀏覽器中。",
                conversationSettingsTitle: "對話設定",
                numAIsLabel: "AI 參與者數量 (2-5):",
                conversationTopicLabel: "對話主題 (可選):",
                conversationTopicPlaceholder: "例如：AI的道德倫理",
                maxTurnsLabel: "最大對話輪次 (每AI發言一次算一輪):",
                rateLimitLabel: "每分鐘最大對話數 (AI發言次數):",
                autoNextTurnText: "自動進行下一輪",
                autoNextTurnNote: "啟用後，AI 將自動輪流發言。",
                modelManagementTitle: "模型管理(可選)",
                customModelNameLabel: "添加自定義模型名稱(本身自帶模型)",
                customModelNamePlaceholder: "例如：gemini-1.5-pro",
                addCustomModelBtn: "添加",
                customModelNote: "添加後，模型將出現在下方AI配置的下拉選單中。",
                aiParticipantsConfigTitle: "AI 參與者配置",
                aiCardTitle: "AI",
                aiNameLabel: "名稱:",
                aiModelLabel: "模型:",
                aiPersonaLabel: "個性/風格提示 (可選):",
                aiPersonaPlaceholder: "例如：你是一位資深哲學家...",
                aiDefaultName: "AI",
                startConversationBtn: "開始對話",
                nextTurnBtn: "下一位 AI 發言",
                stopConversationBtn: "終止對話",
                exportLogBtn: "導出對話記錄",
                conversationLogTitle: "對話記錄",
                warningTipTitle: "提示：",
                warningLi1: "API 金鑰僅儲存在您目前的瀏覽器會話中。",
                warningLi2: "預覽版/自定義模型名稱可能變更或不可用，請確認。",
                warningLi3: "直接從瀏覽器呼叫 Google API <strong>極有可能會遇到 CORS 問題</strong>。請檢查瀏覽器控制台。",
                conversationNotStarted: "<em>對話尚未開始... 請在左側配置並開始。</em>",
                loadingText: "AI 正在思考中...",
                rateLimitWaitingText: "速率限制中，等待 {seconds} 秒...",
                userInjectMessageLabel: "你的發言/提問:",
                userInjectMessagePlaceholder: "在此輸入你想對 AI 們說的話...",
                sendUserMessageBtn: "發送給所有AI",
                systemLogPrefix: "系統",
                observerLogPrefix: "你 (觀察者)",
                errorApiKeyNotSet: "錯誤: API 金鑰未設定。",
                errorApiFailure: "API 請求失敗 ({modelName}): {status} - {message}",
                errorApiFailureNoMsg: "API 請求失敗 ({modelName}): {status}",
                errorApiKeyInvalid: " 請檢查 API 金鑰。",
                errorModelNotFound: " 模型 \"{modelName}\" 可能不存在、不可用或您無權限。請確認模型名稱。",
                errorRateLimit: " 請求頻率限制。",
                errorResponseBlocked: "API 回應內容被阻止 ({modelName}): {reason}. {reasonMessage}",
                errorResponseInvalid: "API 回應格式無法識別或為空 ({modelName})。",
                errorApiCall: "調用 API 時發生錯誤 ({modelName}): {message}. 請檢查瀏覽器控制台 (可能是CORS問題)。",
                errorRequestAborted: "API 請求已被用戶中斷。",
                logConversationStarted: "對話開始！主題：{topic}。共 {numAIs} 位 AI，最多 {maxTurns} 輪。每分鐘最多 {rateLimit} 次AI發言。自動發言模式：{autoModeStatus}。",
                logTopicFree: "自由對話",
                logAutoModeOn: "開啟",
                logAutoModeOff: "關閉",
                logMaxTurnsReached: "已達到最大對話輪次。",
                logConversationStopped: "對話已終止。",
                logCustomModelAdded: "自定義模型 \"{modelName}\" 已添加。",
                alertEnterModelName: "請輸入有效的模型名稱。",
                alertModelExists: "模型 \"{modelName}\" 已存在於列表中。",
                logAiFailedToSpeak: "{agentName} 未能成功發言。",
                logAutoRetryNextAi: "自動嘗試下一位 AI...",
                logRateLimitWait: "已達到每分鐘 {rateLimit} 次的發言限制。將在 {seconds} 秒後繼續...",
                modelFlashPreviewName: "Gemini 2.5 Flash 預覽版 (04-17)",
                modelFlashName: "Gemini 2.0 Flash",
                modelCustomSuffix: "(自定義)"
            }
        };

        let availableModels = [ // Base values, names will be localized
            { nameKey: "modelFlashPreviewName", value: "gemini-2.5-flash-preview-04-17" },
            { nameKey: "modelFlashName", value: "gemini-2.0-flash" }
        ];

        function setLanguage(lang) {
            currentLanguage = lang;
            try { localStorage.setItem('aiArenaLanguage', lang); } catch(e) { console.warn("Local storage unavailable for language preference."); }
            
            const t = translations[lang];
            document.documentElement.lang = lang === 'zh' ? 'zh-TW' : 'en';
            document.title = t.pageTitle;

            // Header and general
            document.getElementById('headerTitle').textContent = t.headerTitle;
            if (lang === 'en') {
                langEnBtn.classList.add('active');
                langZhBtn.classList.remove('active');
            } else {
                langZhBtn.classList.add('active');
                langEnBtn.classList.remove('active');
            }

            // Config Panel
            document.getElementById('apiKeyCardTitle').innerHTML = t.apiKeyCardTitle;
            apiKeyInput.placeholder = t.apiKeyPlaceholder;
            getApiKeyBtn.textContent = t.getApiKeyBtn;
            getApiKeyBtn.title = t.getApiKeyBtnTitle;
            document.getElementById('apiKeyNote').textContent = t.apiKeyNote;

            document.getElementById('conversationSettingsTitle').textContent = t.conversationSettingsTitle;
            document.getElementById('numAIsLabel').textContent = t.numAIsLabel;
            document.getElementById('conversationTopicLabel').textContent = t.conversationTopicLabel;
            conversationTopicInput.placeholder = t.conversationTopicPlaceholder;
            document.getElementById('maxTurnsLabel').textContent = t.maxTurnsLabel;
            document.getElementById('rateLimitLabel').textContent = t.rateLimitLabel;
            document.getElementById('autoNextTurnText').textContent = t.autoNextTurnText;
            document.getElementById('autoNextTurnNote').textContent = t.autoNextTurnNote;
            
            document.getElementById('modelManagementTitle').textContent = t.modelManagementTitle;
            document.getElementById('customModelNameLabel').textContent = t.customModelNameLabel;
            customModelNameInput.placeholder = t.customModelNamePlaceholder; // Update placeholder too
            addCustomModelBtn.textContent = t.addCustomModelBtn;
            document.getElementById('customModelNote').textContent = t.customModelNote;
            
            document.getElementById('aiParticipantsConfigTitle').textContent = t.aiParticipantsConfigTitle; 
            updateAgentConfigUI(); // Re-render AI cards with new language

            startConversationBtn.textContent = t.startConversationBtn;
            nextTurnBtn.textContent = t.nextTurnBtn;
            stopConversationBtn.textContent = t.stopConversationBtn;
            exportLogBtn.textContent = t.exportLogBtn;

            // Chat Display Panel
            document.getElementById('conversationLogTitle').textContent = t.conversationLogTitle;
            document.getElementById('warningTipTitle').textContent = t.warningTipTitle;
            document.getElementById('warningLi1').innerHTML = t.warningLi1;
            document.getElementById('warningLi2').innerHTML = t.warningLi2;
            document.getElementById('warningLi3').innerHTML = t.warningLi3;
            
            if (conversationLogDiv.firstChild && conversationLogDiv.firstChild.id === 'conversationNotStarted') {
                 document.getElementById('conversationNotStarted').innerHTML = t.conversationNotStarted;
            }
            document.getElementById('loadingText').textContent = t.loadingText; 

            document.getElementById('userInjectMessageLabel').textContent = t.userInjectMessageLabel;
            userInjectMessageInput.placeholder = t.userInjectMessagePlaceholder;
            sendUserMessageBtn.textContent = t.sendUserMessageBtn;
        }


        // --- Utility Functions ---
        function showLoading(show) {
            const t = translations[currentLanguage];
            loadingIndicator.style.display = show ? 'block' : 'none';
            if (show && loadingIndicator.querySelector('p').textContent.includes(t.rateLimitWaitingText.substring(0,10))) { 
                // Don't overwrite rate limit message
            } else {
                loadingIndicator.querySelector('p').textContent = t.loadingText;
            }
            nextTurnBtn.disabled = show || !conversationActive || autoNextTurnCheckbox.checked;
            startConversationBtn.disabled = show || conversationActive;
            sendUserMessageBtn.disabled = show || !conversationActive;
        }

        function sanitizeHTML(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        function logMessage(sender, message, turnType = 'ai-turn') {
            const t = translations[currentLanguage];
            let localizedSender = sender;
            if (sender === "系統" || sender === "System") localizedSender = t.systemLogPrefix;
            else if (sender === "你 (觀察者)" || sender === "You (Observer)") localizedSender = t.observerLogPrefix;

            const turnDiv = document.createElement('div');
            turnDiv.classList.add('chat-turn', turnType);

            // Basic Markdown to HTML (bold, italic, basic lists)
            let formattedMessage = sanitizeHTML(message); // Sanitize first
            // Newlines for AI output
            // formattedMessage = formattedMessage.replace(/\n/g, '<br>');

            // Bold: **text** or __text__
            formattedMessage = formattedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formattedMessage = formattedMessage.replace(/__(.*?)__/g, '<strong>$1</strong>');
            // Italic: *text* or _text_
            formattedMessage = formattedMessage.replace(/\*(.*?)\*/g, '<em>$1</em>');
            formattedMessage = formattedMessage.replace(/_(.*?)_/g, '<em>$1</em>');
            // Basic unordered lists (lines starting with * , + , or - )
            // This is a bit tricky to do perfectly with regex without more complex parsing
            // Handle simple cases where list items are on new lines
            formattedMessage = formattedMessage.replace(/^(\s*[\*\-\+]\s+)(.*)/gm, '<li>$2</li>');
            // Wrap consecutive <li> items in <ul>
            if (formattedMessage.includes('<li>')) {
                formattedMessage = formattedMessage.replace(/(<li>.*<\/li>\s*)+/g, (match) => `<ul>${match}</ul>`);
            }


            turnDiv.innerHTML = `<span class="sender">${sanitizeHTML(localizedSender)}:</span><div class="message-content">${formattedMessage}</div>`;
            
            const notStartedMsg = document.getElementById('conversationNotStarted');
            if (notStartedMsg) {
                 conversationLogDiv.innerHTML = ''; // Clear "not started" message
            }
            conversationLogDiv.appendChild(turnDiv);
            conversationLogDiv.scrollTop = conversationLogDiv.scrollHeight;
            fullConversationHistory.push({ sender: localizedSender, message }); 
        }

        function updateAgentConfigUI() {
            const t = translations[currentLanguage];
            const mainTitleEl = document.getElementById('aiParticipantsConfigTitle');
            if (mainTitleEl) mainTitleEl.textContent = t.aiParticipantsConfigTitle;

            let configHTML = ''; 
            const numAIsVal = parseInt(numAIsInput.value);
             if (isNaN(numAIsVal) || numAIsVal < 2 || numAIsVal > 5) {
                numAIsInput.value = Math.max(2, Math.min(5, isNaN(numAIsVal) ? 2 : numAIsVal));
            }
            
            const localizedModels = availableModels.map(m => {
                let name = t[m.nameKey] || m.value; 
                if (m.isCustom) name += ` ${t.modelCustomSuffix}`;
                return { name, value: m.value };
            });

            for (let i = 0; i < parseInt(numAIsInput.value); i++) {
                const aiId = i + 1;
                const existingNameInput = document.getElementById(`aiName${aiId}`);
                const existingModelSelect = document.getElementById(`aiModel${aiId}`);
                const existingPersonaTextarea = document.getElementById(`aiPersona${aiId}`);

                const currentName = existingNameInput ? existingNameInput.value : `${t.aiDefaultName} ${aiId}`;
                const currentModelValue = existingModelSelect ? existingModelSelect.value : (localizedModels.length > 0 ? localizedModels[0].value : '');
                const currentPersona = existingPersonaTextarea ? existingPersonaTextarea.value : "";

                configHTML += `
                    <div class="ai-config-card">
                        <h4>${t.aiCardTitle} ${aiId}</h4>
                        <label for="aiName${aiId}">${t.aiNameLabel}</label>
                        <input type="text" id="aiName${aiId}" value="${sanitizeHTML(currentName)}">
                        <label for="aiModel${aiId}">${t.aiModelLabel}</label>
                        <select id="aiModel${aiId}">
                            ${localizedModels.map(m => `<option value="${m.value}" ${m.value === currentModelValue ? 'selected' : ''} title="${m.value}">${sanitizeHTML(m.name)}</option>`).join('')}
                        </select>
                        <label for="aiPersona${aiId}">${t.aiPersonaLabel}</label>
                        <textarea id="aiPersona${aiId}" placeholder="${t.aiPersonaPlaceholder}">${sanitizeHTML(currentPersona)}</textarea>
                    </div>
                `;
            }
            
            Array.from(aiAgentsConfigContainer.getElementsByClassName('ai-config-card')).forEach(card => card.remove());
            aiAgentsConfigContainer.insertAdjacentHTML('beforeend', configHTML);
        }
        numAIsInput.addEventListener('input', updateAgentConfigUI);

        // --- Gemini API Call ---
        async function callGeminiApi(prompt, modelName, agentHistory) {
            const t = translations[currentLanguage];
            if (!GEMINI_API_KEY) {
                logMessage(t.systemLogPrefix, t.errorApiKeyNotSet, 'user-turn');
                return null;
            }
            showLoading(true);
            abortController = new AbortController();

            const fullModelName = modelName.startsWith('models/') ? modelName : `models/${modelName}`;
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/${fullModelName}:generateContent?key=${GEMINI_API_KEY}`;

            const contents = [...agentHistory];
            contents.push({ role: "user", parts: [{ text: prompt }] });

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents, generationConfig: { /* temperature: 0.7, maxOutputTokens: 800 */ } }),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: "Unable to parse error response" } }));
                    let errorMsgTemplate = errorData.error && errorData.error.message ? t.errorApiFailure : t.errorApiFailureNoMsg;
                    let errorMsg = errorMsgTemplate
                        .replace("{modelName}", modelName)
                        .replace("{status}", response.status)
                        .replace("{message}", (errorData.error && errorData.error.message) || "N/A");

                    if (response.status === 400 && errorData.error?.message?.includes("API key not valid")) errorMsg += t.errorApiKeyInvalid;
                    else if (response.status === 400 && (errorData.error?.message?.includes("tunedModels") || errorData.error?.message?.includes("permission") || errorData.error?.message?.toLowerCase().includes("model not found") )) {
                         errorMsg += t.errorModelNotFound.replace("{modelName}", modelName);
                    }
                    else if (response.status === 429) errorMsg += t.errorRateLimit;
                    logMessage(t.systemLogPrefix, errorMsg, 'user-turn');
                    console.error("API Error:", errorData);
                    showLoading(false);
                    return null;
                }
                const data = await response.json();
                showLoading(false);

                if (data.candidates && data.candidates[0]?.content?.parts) {
                    const aiResponseText = data.candidates[0].content.parts.map(p => p.text).join("\n");
                    agentHistory.push({ role: "user", parts: [{text: prompt}] });
                    agentHistory.push({ role: "model", parts: [{text: aiResponseText}] });
                    return aiResponseText;
                } else if (data.promptFeedback && data.promptFeedback.blockReason) {
                    const blockMsg = t.errorResponseBlocked
                        .replace("{modelName}", modelName)
                        .replace("{reason}", data.promptFeedback.blockReason)
                        .replace("{reasonMessage}", data.promptFeedback.blockReasonMessage || '');
                    logMessage(t.systemLogPrefix, blockMsg, 'user-turn');
                    // Let the AI "say" it was blocked
                    return `(My response was blocked due to: ${data.promptFeedback.blockReason}${data.promptFeedback.blockReasonMessage ? ` - ${data.promptFeedback.blockReasonMessage}` : ''})`;

                } else {
                    logMessage(t.systemLogPrefix, t.errorResponseInvalid.replace("{modelName}", modelName), 'user-turn');
                    console.log("Unexpected API response:", data);
                    return "(AI failed to generate a valid response)";
                }
            } catch (error) {
                showLoading(false);
                if (error.name === 'AbortError') {
                    logMessage(t.systemLogPrefix, t.errorRequestAborted, 'user-turn');
                } else {
                    logMessage(t.systemLogPrefix, t.errorApiCall.replace("{modelName}", modelName).replace("{message}", error.message), 'user-turn');
                    console.error("Fetch Error:", error);
                }
                return null;
            } finally {
                abortController = null;
            }
        }

        // --- Conversation Logic ---
        function initializeConversation() {
            const t = translations[currentLanguage];
            GEMINI_API_KEY = apiKeyInput.value.trim();
            if (!GEMINI_API_KEY) {
                alert(t.errorApiKeyNotSet); 
                apiKeyInput.focus();
                return false;
            }

            const numAIs = parseInt(numAIsInput.value);
            currentMaxTurns = parseInt(maxTurnsInput.value) * numAIs;
            currentRateLimit = parseInt(rateLimitInput.value) || 5;
            apiCallTimestamps = [];
            agents = [];
            for (let i = 0; i < numAIs; i++) {
                const aiId = i + 1;
                agents.push({
                    name: document.getElementById(`aiName${aiId}`).value || `${t.aiDefaultName} ${aiId}`,
                    model: document.getElementById(`aiModel${aiId}`).value,
                    persona: document.getElementById(`aiPersona${aiId}`).value || "You are an AI assistant participating in a conversation.", 
                    history: []
                });
            }

            conversationLogDiv.innerHTML = '';
            fullConversationHistory = [];
            currentTurn = 0;
            currentAIIndex = 0;
            conversationActive = true;

            startConversationBtn.style.display = 'none';
            stopConversationBtn.style.display = 'inline-block';
            nextTurnBtn.style.display = 'inline-block';
            nextTurnBtn.disabled = autoNextTurnCheckbox.checked;
            exportLogBtn.style.display = 'inline-block';
            userInputSection.style.display = 'block';

            const autoModeStatus = autoNextTurnCheckbox.checked ? t.logAutoModeOn : t.logAutoModeOff;
            logMessage(t.systemLogPrefix, t.logConversationStarted
                .replace("{topic}", conversationTopicInput.value.trim() || t.logTopicFree)
                .replace("{numAIs}", numAIs)
                .replace("{maxTurns}", maxTurnsInput.value)
                .replace("{rateLimit}", currentRateLimit)
                .replace("{autoModeStatus}", autoModeStatus), 'user-turn');
            return true;
        }

        async function checkRateLimitAndProceed(isFirstTurn = false, userInjectedMessage = null) {
            const t = translations[currentLanguage];
            if (!conversationActive) return; 

            const now = Date.now();
            apiCallTimestamps = apiCallTimestamps.filter(ts => now - ts < 60000);

            if (apiCallTimestamps.length >= currentRateLimit) {
                const timeToWait = Math.max(0, 60000 - (now - apiCallTimestamps[0]));
                const waitSeconds = Math.ceil(timeToWait / 1000);
                logMessage(t.systemLogPrefix, t.logRateLimitWait.replace("{rateLimit}", currentRateLimit).replace("{seconds}", waitSeconds), 'user-turn');
                
                showLoading(true);
                loadingIndicator.querySelector('p').textContent = t.rateLimitWaitingText.replace('{seconds}', waitSeconds);

                setTimeout(() => {
                    if (!conversationActive) {
                        showLoading(false); // Ensure loading is hidden if conversation stopped during wait
                        return; 
                    }
                    loadingIndicator.querySelector('p').textContent = t.loadingText; 
                    nextAITurn(isFirstTurn, userInjectedMessage);
                }, timeToWait + 200); // Add a small buffer
                return;
            }
            nextAITurn(isFirstTurn, userInjectedMessage);
        }

        async function nextAITurn(isFirstTurn = false, userInjectedMessage = null) {
            const t = translations[currentLanguage];
            if (!conversationActive || currentTurn >= currentMaxTurns) {
                if (conversationActive) stopConversation(); 
                if(currentTurn >= currentMaxTurns && fullConversationHistory.length > 0) logMessage(t.systemLogPrefix, t.logMaxTurnsReached, 'user-turn');
                return;
            }
            if (agents.length === 0) { // Safety check
                 stopConversation();
                 logMessage(t.systemLogPrefix, "Error: No AI agents configured.", 'user-turn');
                 return;
            }

            apiCallTimestamps.push(Date.now());

            const currentAgent = agents[currentAIIndex];
            let prompt;
            let contextForThisTurn = "";

            const historyLookBack = Math.min(fullConversationHistory.length, 6); // Limit context size (3 turns approx)
            if (historyLookBack > 0) {
                contextForThisTurn = "This is the recent conversation history (last few turns):\n" +
                    fullConversationHistory.slice(-historyLookBack)
                    .map(turn => `${turn.sender}: ${turn.message.substring(0, 300)}${turn.message.length > 300 ? '...' : ''}`) // Limit message length in context
                    .join("\n") + "\n\n";
            }

            if (isFirstTurn) {
                const topic = conversationTopicInput.value.trim();
                prompt = `You are ${currentAgent.name}. ${currentAgent.persona}\nWe are starting a new multi-AI conversation.`;
                if (topic) prompt += ` The main topic is: "${topic}".\nPlease make your opening statement or ask a question related to the topic.`;
                else prompt += ` Please start with any topic you find interesting and make your opening statement or ask a question.`;
            } else {
                prompt = `You are ${currentAgent.name}. ${currentAgent.persona}\n${contextForThisTurn}It's your turn. Please continue the conversation naturally based on the above. Address other participants if relevant.`;
            }

            if (userInjectedMessage) {
                 prompt += `\n\nA human observer has just said: "${userInjectedMessage}". Please acknowledge or respond to this in your turn.`;
                 // This modification to agent history will be handled by the API call logic
                 // The goal is to make the model aware of this specific interjection for the current turn.
                 // It will be part of the user prompt to the API for this turn.
            }
            
            // Prepare history for the API call: system prompt + agent's own past turns.
            let agentApiHistory = []; 
            // System prompt for the agent
            let systemPrompt = `You are ${currentAgent.name}. Your persona: "${currentAgent.persona || 'You are a helpful AI assistant.'}" You are participating in a multi-AI discussion. Be concise and stay in character.`;
            if(currentAgent.model.includes("gemini-1.5") || currentAgent.model.includes("gemini-2.")){ // For newer models that might support system_instruction
                // This is a guess, official API might use a different field for system instruction
                // For now, let's prepend it as a user message followed by an "OK" model message
                 agentApiHistory.push({role: 'user', parts: [{text: systemPrompt}]});
                 agentApiHistory.push({role: 'model', parts: [{text: "Understood. I am ready to participate."}]});
            } else {
                 // For older models, just prepend system context to the first user message in history
                 // If there's no userInjectedMessage, this will be handled by the main `prompt` construction.
                 // if (agentApiHistory.length === 0) prompt = systemPrompt + "\n\n" + prompt;
                 // This is complex. Simpler to ensure `prompt` itself has this.
                 // The main `prompt` already contains persona.
            }


            // Add agent's own conversation history (last few turns)
            // Note: 'currentAgent.history' contains {role: "user", parts:[{text: "..."}]}, {role:"model", parts:[{text:"..."}]}
            const agentSpecificHistoryLookback = 4 * 2; // about 4 turns for the agent itself
            if(currentAgent.history.length > agentSpecificHistoryLookback) {
                agentApiHistory.push(...currentAgent.history.slice(-agentSpecificHistoryLookback));
            } else {
                agentApiHistory.push(...currentAgent.history);
            }


            const aiResponse = await callGeminiApi(prompt, currentAgent.model, agentApiHistory);
            // currentAgent.history IS updated inside callGeminiApi if successful.

            if (!conversationActive) return; 

            if (aiResponse) {
                logMessage(currentAgent.name, aiResponse, 'ai-turn');
                currentTurn++;
                currentAIIndex = (currentAIIndex + 1) % agents.length;
                if (currentTurn >= currentMaxTurns) {
                    stopConversation();
                    logMessage(t.systemLogPrefix, t.logMaxTurnsReached, 'user-turn');
                } else if (conversationActive && autoNextTurnCheckbox.checked) { 
                    checkRateLimitAndProceed(false, null);
                }
            } else {
                logMessage(t.systemLogPrefix, t.logAiFailedToSpeak.replace("{agentName}", currentAgent.name), 'user-turn');
                if (agents.length > 0) currentAIIndex = (currentAIIndex + 1) % agents.length; // Try next AI
                
                if (currentTurn >= currentMaxTurns && conversationActive) {
                    stopConversation();
                } else if (conversationActive && autoNextTurnCheckbox.checked && agents.length > 0) {
                    logMessage(t.systemLogPrefix, t.logAutoRetryNextAi, 'user-turn');
                    setTimeout(() => {
                        if (conversationActive) checkRateLimitAndProceed(false, null);
                    }, 500); 
                }
            }
             if (conversationActive && !autoNextTurnCheckbox.checked) {
                showLoading(false); // Ensure loading is off if not auto-proceeding
                nextTurnBtn.disabled = false;
            }
        }

        function stopConversation() {
            const t = translations[currentLanguage];
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            conversationActive = false;
            logMessage(t.systemLogPrefix, t.logConversationStopped, 'user-turn');
            startConversationBtn.style.display = 'inline-block';
            startConversationBtn.disabled = false;
            stopConversationBtn.style.display = 'none';
            nextTurnBtn.style.display = 'none';
            userInputSection.style.display = 'none';
            showLoading(false);
        }

        function exportConversationLog() {
            const t = translations[currentLanguage];
            let logText = `AI Arena Conversation Log\nTopic: ${conversationTopicInput.value.trim() || t.logTopicFree}\n`; 
            logText += `Participants:\n${agents.map(a => `  - ${a.name} (Model: ${a.model}, Persona: ${a.persona || 'None'})`).join('\n')}\n\n`;
            logText += "------------------------------------\n\n";
            fullConversationHistory.forEach(turn => {
                logText += `${turn.sender}:\n${turn.message}\n\n`;
            });
            logText += "------------------------------------\nConversation End";

            const blob = new Blob([logText], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `AI_Arena_Log_${new Date().toISOString().slice(0,16).replace(/[:T]/g,'-')}.txt`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // --- Event Listeners ---
        apiKeyInput.addEventListener('change', () => {
            GEMINI_API_KEY = apiKeyInput.value.trim();
            if (GEMINI_API_KEY) {
                try { sessionStorage.setItem('aiArenaApiKey', GEMINI_API_KEY); } catch (e) { console.warn("Session storage unavailable."); }
            }
        });
        try {
            const storedKey = sessionStorage.getItem('aiArenaApiKey');
            if (storedKey) {
                GEMINI_API_KEY = storedKey;
                apiKeyInput.value = storedKey;
            }
        } catch (e) { console.warn("Session storage unavailable.");}

        getApiKeyBtn.addEventListener('click', () => {
            window.open('https://aistudio.google.com/app/apikey', '_blank');
        });

        addCustomModelBtn.addEventListener('click', () => {
            const t = translations[currentLanguage];
            const modelName = customModelNameInput.value.trim();
            if (modelName && !availableModels.some(m => m.value === modelName)) {
                availableModels.push({ nameKey: modelName, value: modelName, isCustom: true }); 
                updateAgentConfigUI(); 
                customModelNameInput.value = '';
                logMessage(t.systemLogPrefix, t.logCustomModelAdded.replace("{modelName}", modelName), 'user-turn');
            } else if (!modelName) {
                alert(t.alertEnterModelName);
            } else {
                alert(t.alertModelExists.replace("{modelName}", modelName));
            }
        });

        startConversationBtn.addEventListener('click', () => {
            if (initializeConversation()) {
                checkRateLimitAndProceed(true);
            }
        });

        nextTurnBtn.addEventListener('click', () => {
            if (conversationActive && !autoNextTurnCheckbox.checked) {
                nextTurnBtn.disabled = true; // Disable immediately on click
                checkRateLimitAndProceed();
            }
        });

        stopConversationBtn.addEventListener('click', stopConversation);
        exportLogBtn.addEventListener('click', exportConversationLog);

        sendUserMessageBtn.addEventListener('click', () => {
            const t = translations[currentLanguage];
            const userMessage = userInjectMessageInput.value.trim();
            if (!userMessage || !conversationActive) return;
            logMessage(t.observerLogPrefix, userMessage, 'user-turn'); // Log it first
            userInjectMessageInput.value = '';
            if (autoNextTurnCheckbox.checked) {
                // If auto, the next AI turn might already be queued or running.
                // For simplicity, we inject into the *next* scheduled AI turn.
                // Stop current AI if it's thinking, then proceed with user message for next.
                if (abortController) {
                    abortController.abort(); // Abort current API call if any
                    // The API call error handler will eventually call showLoading(false)
                    // We might need to explicitly re-enable buttons if abort leads to no next turn.
                    // However, checkRateLimitAndProceed will handle the next turn.
                }
                // Add a small delay to ensure any aborted call is processed.
                setTimeout(() => checkRateLimitAndProceed(false, userMessage), 100);

            } else {
                // Manual mode, the user message will be part of the next manual "Next AI Speaks"
                checkRateLimitAndProceed(false, userMessage);
            }
        });

        autoNextTurnCheckbox.addEventListener('change', () => {
            const t = translations[currentLanguage];
            if (conversationActive) {
                nextTurnBtn.disabled = autoNextTurnCheckbox.checked || loadingIndicator.style.display === 'block';
                if (autoNextTurnCheckbox.checked && 
                    loadingIndicator.style.display !== 'block' && 
                    currentTurn < currentMaxTurns &&
                    agents.length > 0) {
                    logMessage(t.systemLogPrefix, t.logAutoModeOn + ". " + t.logAutoRetryNextAi, 'user-turn');
                    checkRateLimitAndProceed(false, null);
                } else if (!autoNextTurnCheckbox.checked) {
                     logMessage(t.systemLogPrefix, t.logAutoModeOff + ". " + (translations[currentLanguage].nextTurnBtn) + " " + (translations[currentLanguage].userInjectMessageLabel.split(':')[0]), 'user-turn');
                     if (abortController) { // If an AI was speaking due to auto mode, stop it.
                        abortController.abort();
                     }
                     showLoading(false); // Ensure loading is off
                }
            } else {
                nextTurnBtn.disabled = autoNextTurnCheckbox.checked;
            }
        });
        
        langEnBtn.addEventListener('click', () => setLanguage('en'));
        langZhBtn.addEventListener('click', () => setLanguage('zh'));

        // Initial UI setup
        try {
            const preferredLang = localStorage.getItem('aiArenaLanguage');
            if (preferredLang && translations[preferredLang]) {
                currentLanguage = preferredLang;
            }
        } catch(e) { console.warn("Local storage unavailable for loading language preference.");}
        
        setLanguage(currentLanguage); 

        if (!conversationLogDiv.hasChildNodes() || (conversationLogDiv.firstChild && conversationLogDiv.firstChild.id === 'conversationNotStarted')) {
             document.getElementById('conversationNotStarted').innerHTML = translations[currentLanguage].conversationNotStarted;
        }
    </script>
</body>
</html>
