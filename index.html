<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Arena - 多AI對話模擬器</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: #f0f2f5; color: #1c1e21; display: flex; flex-direction: column; min-height: 100vh; line-height: 1.6; }
        header { background-color: #4267B2; color: white; padding: 0.8em 1em; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        .container { display: flex; flex-grow: 1; padding: 1em; gap: 1em; overflow: hidden; }
        .config-panel { width: 340px; flex-shrink: 0; background-color: #fff; padding: 1.5em; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.12); display: flex; flex-direction: column; gap: 1.2em; max-height: calc(100vh - 2em - 50px); overflow-y: auto; }
        .chat-display-panel { flex-grow: 1; min-width: 0; background-color: #fff; padding: 1.5em; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.12); display: flex; flex-direction: column; max-height: calc(100vh - 2em - 50px); }
        .card { background-color: #f7f8fa; padding: 1em; border-radius: 6px; border: 1px solid #dddfe2; }
        h1 {font-size: 1.5em; margin: 0;}
        h2, h3 { color: #4267B2; margin-top: 0; margin-bottom: 0.8em;}
        h3 {font-size: 1.1em;}
        h4 {font-size: 1em; margin-top:0; margin-bottom: 0.5em;}

        label { display: block; margin-bottom: 0.4em; font-weight: 600; color: #4b4f56; font-size: 0.9em; }
        input[type="text"], input[type="password"], input[type="number"], textarea, select { width: 100%; padding: 0.7em; margin-bottom: 0.5em; border: 1px solid #ccd0d5; border-radius: 4px; font-size: 0.95em; box-sizing: border-box; }
        input[type="checkbox"] { width: auto; margin-right: 0.5em; margin-bottom:0; vertical-align: middle; cursor:pointer; }
        textarea { min-height: 60px; resize: vertical; }
        button { background-color: #42b72a; color: white; border: none; padding: 0.8em 1.2em; border-radius: 6px; cursor: pointer; font-size: 0.95em; font-weight: 600; transition: background-color 0.2s; width: 100%; margin-top: 0.5em; }
        button:first-of-type { margin-top: 0; }
        button:hover { background-color: #36a420; }
        button:disabled { background-color: #ccd0d5; color: #8d949e; cursor: not-allowed; }
        button.inline-button { width: auto; font-size: 0.85em; padding: 0.5em 0.8em; margin-left: 5px; vertical-align: middle; margin-top:0;}
        button.small-action-button { width: auto; font-size: 0.85em; padding: 0.5em 0.8em; margin-top: 0.2em;}

        button.secondary { background-color: #1877f2; }
        button.secondary:hover { background-color: #166fe5; }
        button.danger { background-color: #fa383e; }
        button.danger:hover { background-color: #e0282d; }

        .lang-switcher button { background-color: #f0f2f5; color: #4267B2; border: 1px solid #4267B2; padding: 0.4em 0.8em; font-size: 0.8em; margin-left: 5px; width: auto; }
        .lang-switcher button.active { background-color: #4267B2; color: white; }


        #aiAgentsConfigContainer .ai-config-card { border: 1px solid #ddd; padding: 1em; margin-bottom: 1em; border-radius: 5px; background: #f9f9f9; }
        #conversationLog { flex-grow: 1; overflow-y: auto; border: 1px solid #dddfe2; padding: 1em; background-color: #e9ebee; border-radius: 6px; margin-top:1em;}
        .chat-turn { margin-bottom: 1em; padding: 0.8em 1em; border-radius: 12px; max-width: 85%; word-wrap: break-word; }
        .ai-turn { background-color: #e7f3ff; border-left: 4px solid #1877f2; margin-right: auto; }
        .user-turn { background-color: #d5f0d9; border-left: 4px solid #42b72a; margin-left: auto; text-align: left; } /* System/User messages */
        .chat-turn .sender { font-weight: bold; display: block; margin-bottom: 0.4em; font-size: 0.9em; }
        .chat-turn .message-content { font-size: 0.95em; }
        .loading-indicator { display: none; text-align: center; padding: 1em; }
        .warning { background-color: #fffbe2; color: #5c4d00; padding: 1em; border-radius: 4px; border: 1px solid #fff0b3; margin-bottom: 1em; font-size: 0.85em;}
        #userInputSection { margin-top:1em; padding-top:1em; border-top: 1px solid #dddfe2;}
        #userInputSection button { width: auto; padding: 0.7em 1em; font-size: 0.9em; }

        .input-group { display: flex; align-items: center; margin-bottom: 0.5em;}
        .input-group input { flex-grow: 1; margin-bottom: 0;}
        .input-group button { margin-left: 0.5em; margin-top:0; flex-shrink:0; }


        @media (max-width: 768px) {
            header { flex-direction: column; gap: 0.5em; padding-bottom: 0.5em;}
            .lang-switcher { margin-top: 0.3em; }
            .container { flex-direction: column; padding: 0.5em; overflow-y: auto; }
            .config-panel, .chat-display-panel { width: 100%; box-sizing: border-box; max-height: none; margin-bottom: 1em; }
            .config-panel { order: 1; max-height: 70vh; overflow-y: auto; }
            .chat-display-panel { order: 2; min-height: 300px; }
            h1 {font-size: 1.3em;}
            button {font-size: 0.9em; padding: 0.9em;}
            .chat-turn { max-width: 95%; }
        }
    </style>
</head>
<body>
    <header>
        <h1 id="headerTitle">Gemini Arena</h1>
        <div class="lang-switcher">
            <button id="langEnBtn">English</button>
            <button id="langZhBtn">中文</button>
        </div>
    </header>

    <div class="container">
        <aside class="config-panel">
            <div class="card">
                <h3 id="apiKeyCardTitle"><span style="color:red; font-weight:bold;">重要</span>: API 金鑰</h3>
                <div class="input-group">
                    <input type="password" id="apiKey" placeholder="在此輸入您的 API 金鑰">
                    <button id="getApiKeyBtn" class="inline-button secondary" title="如何獲取 Gemini API 金鑰">獲取金鑰</button>
                </div>
                <small id="apiKeyNote" style="color:red; display:block; margin-bottom:5px; font-size:0.8em;">此金鑰僅儲存在瀏覽器中。</small>
            </div>

            <div class="card">
                <h3 id="conversationSettingsTitle">對話設定</h3>
                <label for="numAIs" id="numAIsLabel">AI 參與者數量 (2-5):</label>
                <input type="number" id="numAIs" value="2" min="2" max="5">

                <label for="conversationTopic" id="conversationTopicLabel">對話主題 (可選):</label>
                <textarea id="conversationTopic" placeholder="例如：AI的道德倫理"></textarea>

                <label for="maxTurns" id="maxTurnsLabel">最大對話輪次 (每AI發言一次算一輪):</label>
                <input type="number" id="maxTurns" value="5" min="1" max="20">

                <label for="rateLimit" id="rateLimitLabel">每分鐘最大對話數 (AI發言次數):</label>
                <input type="number" id="rateLimit" value="5" min="1" max="60">

                <div style="margin-top: 0.8em; padding-top: 0.8em; border-top: 1px solid #eee;">
                    <label for="autoNextTurnCheckbox" id="autoNextTurnLabel" style="display: flex; align-items: center; font-weight: normal; margin-bottom:0; cursor:pointer;">
                        <input type="checkbox" id="autoNextTurnCheckbox">
                        <span id="autoNextTurnText">自動進行下一輪</span>
                    </label>
                    <small id="autoNextTurnNote" style="font-size:0.8em; color: #555; display:block; margin-left: 1.9em;">啟用後，AI 將自動輪流發言。</small>
                </div>
            </div>

            <div class="card">
                <h3 id="modelManagementTitle">模型管理(可選)</h3>
                <label for="customModelName" id="customModelNameLabel">添加自定義模型名稱(本身自帶模型)</label>
                <div class="input-group">
                    <input type="text" id="customModelName" placeholder="例如：gemini-1.5-flash">
                    <button id="addCustomModelBtn" class="small-action-button">添加</button>
                </div>
                 <small id="customModelNote" style="font-size:0.8em; color: #555;">添加後，模型將出現在下方AI配置的下拉選單中。</small>
            </div>


            <div id="aiAgentsConfigContainer">
                <h3 id="aiParticipantsConfigTitle">AI 參與者配置</h3>
                <!-- AI agent configurations will be added here by JS -->
            </div>

            <button id="startConversationBtn">開始對話</button>
            <button id="nextTurnBtn" style="display:none;" class="secondary">下一位 AI 發言</button>
            <button id="stopConversationBtn" class="danger" style="display:none;">終止對話</button>
            <button id="exportLogBtn" style="display:none;">導出對話記錄</button>
        </aside>

        <main class="chat-display-panel">
            <h2 id="conversationLogTitle">對話記錄</h2>
            <div class="warning">
                <strong id="warningTipTitle">提示：</strong>
                <ul>
                    <li id="warningLi1">API 金鑰僅儲存在您目前的瀏覽器會話中。</li>
                    <li id="warningLi2">預覽版/自定義模型名稱可能變更或不可用，請確認。</li>
                    <li id="warningLi3">直接從瀏覽器呼叫 Google API <strong>極有可能會遇到 CORS 問題</strong>。請檢查瀏覽器控制台。</li>
                </ul>
            </div>
            <div id="conversationLog">
                <p id="conversationNotStarted"><em>對話尚未開始... 請在左側配置並開始。</em></p>
            </div>
            <div class="loading-indicator" id="loadingIndicator">
                <p id="loadingText">AI 正在思考中...</p>
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Loading..." width="40">
            </div>
             <div id="userInputSection" style="display:none;">
                <label for="userInjectMessage" id="userInjectMessageLabel">你的發言/提問:</label>
                <textarea id="userInjectMessage" placeholder="在此輸入你想對 AI 們說的話..."></textarea>
                <button id="sendUserMessageBtn" class="secondary">發送給所有AI</button>
            </div>
        </main>
    </div>

    <script>
        // DOM Elements
        const apiKeyInput = document.getElementById('apiKey');
        const getApiKeyBtn = document.getElementById('getApiKeyBtn');
        const numAIsInput = document.getElementById('numAIs');
        const conversationTopicInput = document.getElementById('conversationTopic');
        const maxTurnsInput = document.getElementById('maxTurns');
        const rateLimitInput = document.getElementById('rateLimit');
        const autoNextTurnCheckbox = document.getElementById('autoNextTurnCheckbox');
        const customModelNameInput = document.getElementById('customModelName');
        const addCustomModelBtn = document.getElementById('addCustomModelBtn');
        const aiAgentsConfigContainer = document.getElementById('aiAgentsConfigContainer');
        const startConversationBtn = document.getElementById('startConversationBtn');
        const nextTurnBtn = document.getElementById('nextTurnBtn');
        const stopConversationBtn = document.getElementById('stopConversationBtn');
        const exportLogBtn = document.getElementById('exportLogBtn');
        const conversationLogDiv = document.getElementById('conversationLog');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const userInputSection = document.getElementById('userInputSection');
        const userInjectMessageInput = document.getElementById('userInjectMessage');
        const sendUserMessageBtn = document.getElementById('sendUserMessageBtn');
        const langEnBtn = document.getElementById('langEnBtn');
        const langZhBtn = document.getElementById('langZhBtn');

        // Global Variables
        let GEMINI_API_KEY = '';
        let conversationActive = false;
        let currentTurn = 0;
        let currentAIIndex = 0;
        let currentMaxTurns = 5;
        let agents = [];
        let fullConversationHistory = [];
        let abortController = null;
        let apiCallTimestamps = [];
        let currentRateLimit = 5;
        let currentLanguage = 'zh'; // Default language

        const translations = {
            en: {
                pageTitle: "Gemini Arena - Multi-AI Conversation Simulator",
                headerTitle: "Gemini Arena",
                apiKeyCardTitle: "<span style='color:red; font-weight:bold;'>IMPORTANT</span>: API Key",
                apiKeyPlaceholder: "Enter your API Key here",
                getApiKeyBtn: "Get Key",
                getApiKeyBtnTitle: "How to get a Gemini API Key",
                apiKeyNote: "This key is only stored in your browser.",
                conversationSettingsTitle: "Conversation Settings",
                numAIsLabel: "Number of AI Participants (2-5):",
                conversationTopicLabel: "Conversation Topic (Optional):",
                conversationTopicPlaceholder: "e.g., Ethical implications of AI",
                maxTurnsLabel: "Max Conversation Turns (one turn per AI speech):",
                rateLimitLabel: "Max API Calls per Minute (AI speeches):",
                autoNextTurnText: "Auto next turn",
                autoNextTurnNote: "If enabled, AIs will take turns automatically.",
                modelManagementTitle: "Model Management (Optional)",
                customModelNameLabel: "Add Custom Model Name (built-in models available)",
                customModelNamePlaceholder: "e.g., gemini-1.5-flash",
                addCustomModelBtn: "Add",
                customModelNote: "After adding, the model will appear in the AI config dropdowns below.",
                aiParticipantsConfigTitle: "AI Participant Configuration",
                aiCardTitle: "AI",
                aiNameLabel: "Name:",
                aiModelLabel: "Model:",
                aiPersonaLabel: "Persona/Style Prompt (Optional):",
                aiPersonaPlaceholder: "e.g., You are a seasoned philosopher...",
                aiDefaultName: "AI",
                startConversationBtn: "Start Conversation",
                nextTurnBtn: "Next AI Speaks",
                stopConversationBtn: "Stop Conversation",
                exportLogBtn: "Export Log",
                conversationLogTitle: "Conversation Log",
                warningTipTitle: "Tip:",
                warningLi1: "API Key is only stored in your current browser session.",
                warningLi2: "Preview/custom model names might change or be unavailable. Please verify.",
                warningLi3: "Calling Google API directly from the browser is <strong>highly likely to encounter CORS issues</strong>. Check browser console.",
                conversationNotStarted: "<em>Conversation not started... Please configure and start on the left.</em>",
                loadingText: "AI is thinking...",
                rateLimitWaitingText: "Rate limit reached. Waiting {seconds} seconds...",
                userInjectMessageLabel: "Your Speech/Question:",
                userInjectMessagePlaceholder: "Enter what you want to say to the AIs...",
                sendUserMessageBtn: "Send to all AIs",
                systemLogPrefix: "System",
                observerLogPrefix: "You (Observer)",
                errorApiKeyNotSet: "Error: API Key not set.",
                errorApiFailure: "API request failed ({modelName}): {status} - {message}",
                errorApiFailureNoMsg: "API request failed ({modelName}): {status}",
                errorApiKeyInvalid: " Please check your API key.",
                errorModelNotFound: " Model \"{modelName}\" might not exist, be unavailable, or you lack permission. Please verify the model name.",
                errorRateLimit: " Request frequency limit.",
                errorResponseBlocked: "API response content blocked ({modelName}): {reason}. {reasonMessage}",
                errorResponseInvalid: "API response format unrecognized or empty ({modelName}).",
                errorApiCall: "Error calling API ({modelName}): {message}. Check browser console (could be CORS issue).",
                errorRequestAborted: "API request aborted by user.",
                logConversationStarted: "Conversation started! Topic: {topic}. {numAIs} AIs, max {maxTurns} turns. Max {rateLimit} AI speeches/min. Auto-speak mode: {autoModeStatus}.",
                logTopicFree: "Free talk",
                logAutoModeOn: "ON",
                logAutoModeOff: "OFF",
                logMaxTurnsReached: "Maximum conversation turns reached.",
                logConversationStopped: "Conversation stopped.",
                logCustomModelAdded: "Custom model \"{modelName}\" added.",
                alertEnterModelName: "Please enter a valid model name.",
                alertModelExists: "Model \"{modelName}\" already exists in the list.",
                logAiFailedToSpeak: "{agentName} failed to speak.",
                logAutoRetryNextAi: "Automatically trying next AI...",
                logRateLimitWait: "Reached {rateLimit} calls per minute limit. Will continue in {seconds} seconds...",
                modelFlashPreviewName: "Gemini 1.5 Flash Preview (05-20)", // Example for localizing model names
                modelFlashName: "Gemini 1.5 Flash",
                modelCustomSuffix: "(Custom)"
            },
            zh: {
                pageTitle: "Gemini Arena - 多AI對話模擬器",
                headerTitle: "Gemini Arena",
                apiKeyCardTitle: "<span style='color:red; font-weight:bold;'>重要</span>: API 金鑰",
                apiKeyPlaceholder: "在此輸入您的 API 金鑰",
                getApiKeyBtn: "獲取金鑰",
                getApiKeyBtnTitle: "如何獲取 Gemini API 金鑰",
                apiKeyNote: "此金鑰僅儲存在瀏覽器中。",
                conversationSettingsTitle: "對話設定",
                numAIsLabel: "AI 參與者數量 (2-5):",
                conversationTopicLabel: "對話主題 (可選):",
                conversationTopicPlaceholder: "例如：AI的道德倫理",
                maxTurnsLabel: "最大對話輪次 (每AI發言一次算一輪):",
                rateLimitLabel: "每分鐘最大對話數 (AI發言次數):",
                autoNextTurnText: "自動進行下一輪",
                autoNextTurnNote: "啟用後，AI 將自動輪流發言。",
                modelManagementTitle: "模型管理(可選)",
                customModelNameLabel: "添加自定義模型名稱(本身自帶模型)",
                customModelNamePlaceholder: "例如：gemini-1.5-flash",
                addCustomModelBtn: "添加",
                customModelNote: "添加後，模型將出現在下方AI配置的下拉選單中。",
                aiParticipantsConfigTitle: "AI 參與者配置",
                aiCardTitle: "AI",
                aiNameLabel: "名稱:",
                aiModelLabel: "模型:",
                aiPersonaLabel: "個性/風格提示 (可選):",
                aiPersonaPlaceholder: "例如：你是一位資深哲學家...",
                aiDefaultName: "AI",
                startConversationBtn: "開始對話",
                nextTurnBtn: "下一位 AI 發言",
                stopConversationBtn: "終止對話",
                exportLogBtn: "導出對話記錄",
                conversationLogTitle: "對話記錄",
                warningTipTitle: "提示：",
                warningLi1: "API 金鑰僅儲存在您目前的瀏覽器會話中。",
                warningLi2: "預覽版/自定義模型名稱可能變更或不可用，請確認。",
                warningLi3: "直接從瀏覽器呼叫 Google API <strong>極有可能會遇到 CORS 問題</strong>。請檢查瀏覽器控制台。",
                conversationNotStarted: "<em>對話尚未開始... 請在左側配置並開始。</em>",
                loadingText: "AI 正在思考中...",
                rateLimitWaitingText: "速率限制中，等待 {seconds} 秒...",
                userInjectMessageLabel: "你的發言/提問:",
                userInjectMessagePlaceholder: "在此輸入你想對 AI 們說的話...",
                sendUserMessageBtn: "發送給所有AI",
                systemLogPrefix: "系統",
                observerLogPrefix: "你 (觀察者)",
                errorApiKeyNotSet: "錯誤: API 金鑰未設定。",
                errorApiFailure: "API 請求失敗 ({modelName}): {status} - {message}",
                errorApiFailureNoMsg: "API 請求失敗 ({modelName}): {status}",
                errorApiKeyInvalid: " 請檢查 API 金鑰。",
                errorModelNotFound: " 模型 \"{modelName}\" 可能不存在、不可用或您無權限。請確認模型名稱。",
                errorRateLimit: " 請求頻率限制。",
                errorResponseBlocked: "API 回應內容被阻止 ({modelName}): {reason}. {reasonMessage}",
                errorResponseInvalid: "API 回應格式無法識別或為空 ({modelName})。",
                errorApiCall: "調用 API 時發生錯誤 ({modelName}): {message}. 請檢查瀏覽器控制台 (可能是CORS問題)。",
                errorRequestAborted: "API 請求已被用戶中斷。",
                logConversationStarted: "對話開始！主題：{topic}。共 {numAIs} 位 AI，最多 {maxTurns} 輪。每分鐘最多 {rateLimit} 次AI發言。自動發言模式：{autoModeStatus}。",
                logTopicFree: "自由對話",
                logAutoModeOn: "開啟",
                logAutoModeOff: "關閉",
                logMaxTurnsReached: "已達到最大對話輪次。",
                logConversationStopped: "對話已終止。",
                logCustomModelAdded: "自定義模型 \"{modelName}\" 已添加。",
                alertEnterModelName: "請輸入有效的模型名稱。",
                alertModelExists: "模型 \"{modelName}\" 已存在於列表中。",
                logAiFailedToSpeak: "{agentName} 未能成功發言。",
                logAutoRetryNextAi: "自動嘗試下一位 AI...",
                logRateLimitWait: "已達到每分鐘 {rateLimit} 次的發言限制。將在 {seconds} 秒後繼續...",
                modelFlashPreviewName: "Gemini 1.5 Flash 預覽版 (05-20)",
                modelFlashName: "Gemini 1.5 Flash",
                modelCustomSuffix: "(自定義)"
            }
        };

        let availableModels = [ // Base values, names will be localized
            { nameKey: "modelFlashPreviewName", value: "gemini-1.5-flash-preview-05-20" },
            { nameKey: "modelFlashName", value: "gemini-1.5-flash" } // Corrected to 1.5, as was in HTML
        ];

        function setLanguage(lang) {
            currentLanguage = lang;
            try { localStorage.setItem('aiArenaLanguage', lang); } catch(e) { console.warn("Local storage unavailable for language preference."); }
            
            const t = translations[lang];
            document.documentElement.lang = lang === 'zh' ? 'zh-TW' : 'en';
            document.title = t.pageTitle;

            // Header and general
            document.getElementById('headerTitle').textContent = t.headerTitle;
            if (lang === 'en') {
                langEnBtn.classList.add('active');
                langZhBtn.classList.remove('active');
            } else {
                langZhBtn.classList.add('active');
                langEnBtn.classList.remove('active');
            }

            // Config Panel
            document.getElementById('apiKeyCardTitle').innerHTML = t.apiKeyCardTitle;
            apiKeyInput.placeholder = t.apiKeyPlaceholder;
            getApiKeyBtn.textContent = t.getApiKeyBtn;
            getApiKeyBtn.title = t.getApiKeyBtnTitle;
            document.getElementById('apiKeyNote').textContent = t.apiKeyNote;

            document.getElementById('conversationSettingsTitle').textContent = t.conversationSettingsTitle;
            document.getElementById('numAIsLabel').textContent = t.numAIsLabel;
            document.getElementById('conversationTopicLabel').textContent = t.conversationTopicLabel;
            conversationTopicInput.placeholder = t.conversationTopicPlaceholder;
            document.getElementById('maxTurnsLabel').textContent = t.maxTurnsLabel;
            document.getElementById('rateLimitLabel').textContent = t.rateLimitLabel;
            document.getElementById('autoNextTurnText').textContent = t.autoNextTurnText;
            document.getElementById('autoNextTurnNote').textContent = t.autoNextTurnNote;
            
            document.getElementById('modelManagementTitle').textContent = t.modelManagementTitle;
            document.getElementById('customModelNameLabel').textContent = t.customModelNameLabel;
            customModelNameInput.placeholder = t.customModelNamePlaceholder;
            addCustomModelBtn.textContent = t.addCustomModelBtn;
            document.getElementById('customModelNote').textContent = t.customModelNote;
            
            document.getElementById('aiParticipantsConfigTitle').textContent = t.aiParticipantsConfigTitle; // This title is static
            updateAgentConfigUI(); // Re-render AI cards with new language

            startConversationBtn.textContent = t.startConversationBtn;
            nextTurnBtn.textContent = t.nextTurnBtn;
            stopConversationBtn.textContent = t.stopConversationBtn;
            exportLogBtn.textContent = t.exportLogBtn;

            // Chat Display Panel
            document.getElementById('conversationLogTitle').textContent = t.conversationLogTitle;
            document.getElementById('warningTipTitle').textContent = t.warningTipTitle;
            document.getElementById('warningLi1').innerHTML = t.warningLi1;
            document.getElementById('warningLi2').innerHTML = t.warningLi2;
            document.getElementById('warningLi3').innerHTML = t.warningLi3;
            
            if (conversationLogDiv.firstChild && conversationLogDiv.firstChild.id === 'conversationNotStarted') {
                 document.getElementById('conversationNotStarted').innerHTML = t.conversationNotStarted;
            }
            document.getElementById('loadingText').textContent = t.loadingText; // Default loading text

            document.getElementById('userInjectMessageLabel').textContent = t.userInjectMessageLabel;
            userInjectMessageInput.placeholder = t.userInjectMessagePlaceholder;
            sendUserMessageBtn.textContent = t.sendUserMessageBtn;
        }


        // --- Utility Functions ---
        function showLoading(show) {
            const t = translations[currentLanguage];
            loadingIndicator.style.display = show ? 'block' : 'none';
            if (show && loadingIndicator.querySelector('p').textContent.includes(t.rateLimitWaitingText.substring(0,10))) { // a bit hacky check
                // Don't overwrite rate limit message
            } else {
                loadingIndicator.querySelector('p').textContent = t.loadingText;
            }
            nextTurnBtn.disabled = show || !conversationActive || autoNextTurnCheckbox.checked;
            startConversationBtn.disabled = show || conversationActive;
            sendUserMessageBtn.disabled = show || !conversationActive;
        }

        function sanitizeHTML(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        function logMessage(sender, message, turnType = 'ai-turn') {
            const t = translations[currentLanguage];
            let localizedSender = sender;
            if (sender === "系統" || sender === "System") localizedSender = t.systemLogPrefix;
            else if (sender === "你 (觀察者)" || sender === "You (Observer)") localizedSender = t.observerLogPrefix;

            const turnDiv = document.createElement('div');
            turnDiv.classList.add('chat-turn', turnType);

            let formattedMessage = sanitizeHTML(message);
            formattedMessage = formattedMessage.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            formattedMessage = formattedMessage.replace(/\*(.*?)\*/g, '<em>$1</em>');
            formattedMessage = formattedMessage.replace(/(\r\n|\r|\n)([\*\-\+] +(.*))/g, (match, p1, p2, p3) => `${p1}<li>${p3.trim()}</li>`);
            formattedMessage = formattedMessage.replace(/(<li>.*?<\/li>\s*)+/g, (match) => `<ul>${match}</ul>`);

            turnDiv.innerHTML = `<span class="sender">${sanitizeHTML(localizedSender)}:</span><div class="message-content">${formattedMessage}</div>`;
            
            const notStartedMsg = document.getElementById('conversationNotStarted');
            if (notStartedMsg) {
                 conversationLogDiv.innerHTML = ''; // Clear "not started" message
            }
            conversationLogDiv.appendChild(turnDiv);
            conversationLogDiv.scrollTop = conversationLogDiv.scrollHeight;
            fullConversationHistory.push({ sender: localizedSender, message }); // Store with localized sender for consistency if re-rendering
        }

        function updateAgentConfigUI() {
            const t = translations[currentLanguage];
            // Update the main title for AI Participants Config if it's not already part of the static text update
            const mainTitleEl = document.getElementById('aiParticipantsConfigTitle');
            if (mainTitleEl) mainTitleEl.textContent = t.aiParticipantsConfigTitle;


            let configHTML = ''; // Build HTML string then set innerHTML once
            const numAIs = parseInt(numAIsInput.value);
             if (isNaN(numAIs) || numAIs < 2 || numAIs > 5) {
                numAIsInput.value = Math.max(2, Math.min(5, isNaN(numAIs) ? 2 : numAIs));
                // No early return, proceed to render with corrected value
            }
            
            // Localize model names for the dropdown
            const localizedModels = availableModels.map(m => {
                let name = t[m.nameKey] || m.value; // Fallback to value if key not found
                if (m.isCustom) name += ` ${t.modelCustomSuffix}`;
                return { name, value: m.value };
            });

            for (let i = 0; i < numAIsInput.value; i++) {
                const aiId = i + 1;
                // Preserve existing values if possible when re-rendering due to language change
                const existingNameInput = document.getElementById(`aiName${aiId}`);
                const existingModelSelect = document.getElementById(`aiModel${aiId}`);
                const existingPersonaTextarea = document.getElementById(`aiPersona${aiId}`);

                const currentName = existingNameInput ? existingNameInput.value : `${t.aiDefaultName} ${aiId}`;
                const currentModel = existingModelSelect ? existingModelSelect.value : (localizedModels.length > 0 ? localizedModels[0].value : '');
                const currentPersona = existingPersonaTextarea ? existingPersonaTextarea.value : "";

                configHTML += `
                    <div class="ai-config-card">
                        <h4>${t.aiCardTitle} ${aiId}</h4>
                        <label for="aiName${aiId}">${t.aiNameLabel}</label>
                        <input type="text" id="aiName${aiId}" value="${sanitizeHTML(currentName)}">
                        <label for="aiModel${aiId}">${t.aiModelLabel}</label>
                        <select id="aiModel${aiId}">
                            ${localizedModels.map(m => `<option value="${m.value}" ${m.value === currentModel ? 'selected' : ''} title="${m.value}">${m.name}</option>`).join('')}
                        </select>
                        <label for="aiPersona${aiId}">${t.aiPersonaLabel}</label>
                        <textarea id="aiPersona${aiId}" placeholder="${t.aiPersonaPlaceholder}">${sanitizeHTML(currentPersona)}</textarea>
                    </div>
                `;
            }
            // Clear only the cards, not the title if title is static
            const containerContent = aiAgentsConfigContainer.querySelector('.ai-config-card') ? aiAgentsConfigContainer : document.createElement('div');
            if(aiAgentsConfigContainer.children.length > 1) { // If cards exist, replace them
                // Remove existing cards
                Array.from(aiAgentsConfigContainer.getElementsByClassName('ai-config-card')).forEach(card => card.remove());
            }
            aiAgentsConfigContainer.insertAdjacentHTML('beforeend', configHTML);
        }
        numAIsInput.addEventListener('input', updateAgentConfigUI);
        // Initial call to render based on default numAIs and language is handled by setLanguage -> updateAgentConfigUI

        // --- Gemini API Call ---
        async function callGeminiApi(prompt, modelName, agentHistory) {
            const t = translations[currentLanguage];
            if (!GEMINI_API_KEY) {
                logMessage(t.systemLogPrefix, t.errorApiKeyNotSet, 'user-turn');
                return null;
            }
            showLoading(true);
            abortController = new AbortController();

            const fullModelName = modelName.startsWith('models/') ? modelName : `models/${modelName}`;
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/${fullModelName}:generateContent?key=${GEMINI_API_KEY}`;

            const contents = [...agentHistory];
            contents.push({ role: "user", parts: [{ text: prompt }] });

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents, generationConfig: { /* temperature: 0.7, maxOutputTokens: 800 */ } }),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: "Unable to parse error response" } }));
                    let errorMsgTemplate = errorData.error && errorData.error.message ? t.errorApiFailure : t.errorApiFailureNoMsg;
                    let errorMsg = errorMsgTemplate
                        .replace("{modelName}", modelName)
                        .replace("{status}", response.status)
                        .replace("{message}", (errorData.error && errorData.error.message) || "N/A");

                    if (response.status === 400 && errorData.error?.message?.includes("API key not valid")) errorMsg += t.errorApiKeyInvalid;
                    else if (response.status === 400 && (errorData.error?.message?.includes("tunedModels") || errorData.error?.message?.includes("permission") || errorData.error?.message?.toLowerCase().includes("model not found") )) {
                         errorMsg += t.errorModelNotFound.replace("{modelName}", modelName);
                    }
                    else if (response.status === 429) errorMsg += t.errorRateLimit;
                    logMessage(t.systemLogPrefix, errorMsg, 'user-turn');
                    console.error("API Error:", errorData);
                    showLoading(false);
                    return null;
                }
                const data = await response.json();
                showLoading(false);

                if (data.candidates && data.candidates[0]?.content?.parts) {
                    const aiResponseText = data.candidates[0].content.parts.map(p => p.text).join("\n");
                    agentHistory.push({ role: "user", parts: [{text: prompt}] });
                    agentHistory.push({ role: "model", parts: [{text: aiResponseText}] });
                    return aiResponseText;
                } else if (data.promptFeedback && data.promptFeedback.blockReason) {
                    logMessage(t.systemLogPrefix, t.errorResponseBlocked
                        .replace("{modelName}", modelName)
                        .replace("{reason}", data.promptFeedback.blockReason)
                        .replace("{reasonMessage}", data.promptFeedback.blockReasonMessage || ''), 'user-turn');
                    return `(My response was partially omitted due to content safety policy: ${data.promptFeedback.blockReason})`;
                } else {
                    logMessage(t.systemLogPrefix, t.errorResponseInvalid.replace("{modelName}", modelName), 'user-turn');
                    console.log("Unexpected API response:", data);
                    return "(AI failed to generate a valid response)";
                }
            } catch (error) {
                showLoading(false);
                if (error.name === 'AbortError') {
                    logMessage(t.systemLogPrefix, t.errorRequestAborted, 'user-turn');
                } else {
                    logMessage(t.systemLogPrefix, t.errorApiCall.replace("{modelName}", modelName).replace("{message}", error.message), 'user-turn');
                    console.error("Fetch Error:", error);
                }
                return null;
            } finally {
                abortController = null;
            }
        }

        // --- Conversation Logic ---
        function initializeConversation() {
            const t = translations[currentLanguage];
            GEMINI_API_KEY = apiKeyInput.value.trim();
            if (!GEMINI_API_KEY) {
                alert(t.errorApiKeyNotSet); // Simple alert for this common issue
                apiKeyInput.focus();
                return false;
            }

            const numAIs = parseInt(numAIsInput.value);
            currentMaxTurns = parseInt(maxTurnsInput.value) * numAIs;
            currentRateLimit = parseInt(rateLimitInput.value) || 5;
            apiCallTimestamps = [];
            agents = [];
            for (let i = 0; i < numAIs; i++) {
                const aiId = i + 1;
                agents.push({
                    name: document.getElementById(`aiName${aiId}`).value || `${t.aiDefaultName} ${aiId}`,
                    model: document.getElementById(`aiModel${aiId}`).value,
                    persona: document.getElementById(`aiPersona${aiId}`).value || "You are an AI assistant participating in a conversation.", // Generic persona
                    history: []
                });
            }

            conversationLogDiv.innerHTML = '';
            fullConversationHistory = [];
            currentTurn = 0;
            currentAIIndex = 0;
            conversationActive = true;

            startConversationBtn.style.display = 'none';
            stopConversationBtn.style.display = 'inline-block';
            nextTurnBtn.style.display = 'inline-block';
            nextTurnBtn.disabled = autoNextTurnCheckbox.checked;
            exportLogBtn.style.display = 'inline-block';
            userInputSection.style.display = 'block';

            const autoModeStatus = autoNextTurnCheckbox.checked ? t.logAutoModeOn : t.logAutoModeOff;
            logMessage(t.systemLogPrefix, t.logConversationStarted
                .replace("{topic}", conversationTopicInput.value.trim() || t.logTopicFree)
                .replace("{numAIs}", numAIs)
                .replace("{maxTurns}", maxTurnsInput.value)
                .replace("{rateLimit}", currentRateLimit)
                .replace("{autoModeStatus}", autoModeStatus), 'user-turn');
            return true;
        }

        async function checkRateLimitAndProceed(isFirstTurn = false, userInjectedMessage = null) {
            const t = translations[currentLanguage];
            if (!conversationActive) return; 

            const now = Date.now();
            apiCallTimestamps = apiCallTimestamps.filter(ts => now - ts < 60000);

            if (apiCallTimestamps.length >= currentRateLimit) {
                const timeToWait = Math.max(0, 60000 - (now - apiCallTimestamps[0]));
                const waitSeconds = Math.ceil(timeToWait / 1000);
                logMessage(t.systemLogPrefix, t.logRateLimitWait.replace("{rateLimit}", currentRateLimit).replace("{seconds}", waitSeconds), 'user-turn');
                
                showLoading(true);
                loadingIndicator.querySelector('p').textContent = t.rateLimitWaitingText.replace('{seconds}', waitSeconds);

                setTimeout(() => {
                    if (!conversationActive) return; 
                    loadingIndicator.querySelector('p').textContent = t.loadingText; // Reset loading text
                    nextAITurn(isFirstTurn, userInjectedMessage);
                }, timeToWait + 200);
                return;
            }
            nextAITurn(isFirstTurn, userInjectedMessage);
        }

        async function nextAITurn(isFirstTurn = false, userInjectedMessage = null) {
            const t = translations[currentLanguage];
            if (!conversationActive || currentTurn >= currentMaxTurns) {
                if (conversationActive) stopConversation(); 
                if(currentTurn >= currentMaxTurns && fullConversationHistory.length > 0) logMessage(t.systemLogPrefix, t.logMaxTurnsReached, 'user-turn');
                return;
            }

            apiCallTimestamps.push(Date.now());

            const currentAgent = agents[currentAIIndex];
            let prompt;
            let contextForThisTurn = "";

            const historyLookBack = Math.min(fullConversationHistory.length, 8); // Keep context concise
            if (historyLookBack > 0) {
                // Using English for context to AI, assuming models are primarily trained in English
                contextForThisTurn = "Here is a summary of the recent conversation:\n" +
                    fullConversationHistory.slice(-historyLookBack)
                    .map(turn => `${turn.sender}: ${turn.message.substring(0, 200)}${turn.message.length > 200 ? '...' : ''}`)
                    .join("\n") + "\n\n";
            }

            if (isFirstTurn) {
                const topic = conversationTopicInput.value.trim();
                prompt = `Hello, ${currentAgent.name}! ${currentAgent.persona}\nWe are starting a new multi-AI conversation.`;
                if (topic) prompt += ` The topic is: "${topic}".\nPlease make your opening statement.`;
                else prompt += ` Please start with any topic and make your opening statement.`;
            } else {
                prompt = `${currentAgent.persona}\n${contextForThisTurn}It's your turn, ${currentAgent.name}. Please continue the conversation based on the above. Keep your response concise and to the point.`;
            }

            if (userInjectedMessage) {
                 prompt += `\n\nA human observer has interjected: "${userInjectedMessage}". Please consider this in your response.`;
                 let tempUserHistoryEntry = {role: "user", parts: [{text: `(A human observer said: “${userInjectedMessage}”)`}]};
                 let tempModelAckEntry = {role: "model", parts: [{text: `(I have noted the observer's message.)`}]}; // Ack in English for model
                 if(currentAgent.history.length > 0 && currentAgent.history[currentAgent.history.length-1].role === 'model'){
                    currentAgent.history.push(tempUserHistoryEntry, tempModelAckEntry);
                 } else {
                     currentAgent.history.push(tempUserHistoryEntry);
                 }
            }
            
            // Persona prompt should be in English for the model generally
            let agentApiHistory = currentAgent.history.slice();
            if (agentApiHistory.length === 0 || !agentApiHistory[0]?.parts[0]?.text.includes(currentAgent.persona.substring(0,10))) {
                 agentApiHistory.unshift({role: 'user', parts: [{text: `${currentAgent.persona}\nYou are in a multi-AI conversation. Your name is ${currentAgent.name}.`}]});
                 if (agentApiHistory.length === 1 || agentApiHistory[1].role !== 'model') {
                    agentApiHistory.push({role: 'model', parts: [{text: "Okay, I understand my role and settings."}]});
                 }
            }
            const agentApiHistoryLimit = 4 * 2; // ~4 turns of context for the agent itself
            if(agentApiHistory.length > agentApiHistoryLimit) {
                agentApiHistory = [agentApiHistory[0], agentApiHistory[1], ...agentApiHistory.slice(-(agentApiHistoryLimit-2))];
            }


            const aiResponse = await callGeminiApi(prompt, currentAgent.model, agentApiHistory);
            currentAgent.history = agentApiHistory; // Update agent's own history

            if (!conversationActive) return; 

            if (aiResponse) {
                logMessage(currentAgent.name, aiResponse, 'ai-turn');
                currentTurn++;
                currentAIIndex = (currentAIIndex + 1) % agents.length;
                if (currentTurn >= currentMaxTurns) {
                    stopConversation();
                    logMessage(t.systemLogPrefix, t.logMaxTurnsReached, 'user-turn');
                } else if (conversationActive && autoNextTurnCheckbox.checked) { 
                    checkRateLimitAndProceed(false, null);
                }
            } else {
                logMessage(t.systemLogPrefix, t.logAiFailedToSpeak.replace("{agentName}", currentAgent.name), 'user-turn');
                if (agents.length > 0) currentAIIndex = (currentAIIndex + 1) % agents.length;
                
                if (currentTurn >= currentMaxTurns && conversationActive) {
                    stopConversation();
                } else if (conversationActive && autoNextTurnCheckbox.checked && agents.length > 0) {
                    logMessage(t.systemLogPrefix, t.logAutoRetryNextAi, 'user-turn');
                    setTimeout(() => {
                        if (conversationActive) checkRateLimitAndProceed(false, null);
                    }, 500); 
                }
            }
            if (conversationActive) {
                 showLoading(loadingIndicator.style.display === 'block');
            }
        }

        function stopConversation() {
            const t = translations[currentLanguage];
            if (abortController) {
                abortController.abort();
            }
            conversationActive = false;
            logMessage(t.systemLogPrefix, t.logConversationStopped, 'user-turn');
            startConversationBtn.style.display = 'inline-block';
            startConversationBtn.disabled = false;
            stopConversationBtn.style.display = 'none';
            nextTurnBtn.style.display = 'none';
            userInputSection.style.display = 'none';
            showLoading(false);
        }

        function exportConversationLog() {
            const t = translations[currentLanguage];
            let logText = `AI Arena Conversation Log\nTopic: ${conversationTopicInput.value.trim() || t.logTopicFree}\n`; // Using English for log file consistency
            logText += `Participants:\n${agents.map(a => `  - ${a.name} (Model: ${a.model}, Persona: ${a.persona || 'None'})`).join('\n')}\n\n`;
            logText += "------------------------------------\n\n";
            fullConversationHistory.forEach(turn => {
                logText += `${turn.sender}:\n${turn.message}\n\n`;
            });
            logText += "------------------------------------\nConversation End";

            const blob = new Blob([logText], { type: 'text/plain;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `AI_Arena_Log_${new Date().toISOString().slice(0,16).replace(/[:T]/g,'-')}.txt`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // --- Event Listeners ---
        apiKeyInput.addEventListener('change', () => {
            GEMINI_API_KEY = apiKeyInput.value.trim();
            if (GEMINI_API_KEY) {
                try { sessionStorage.setItem('aiArenaApiKey', GEMINI_API_KEY); } catch (e) { console.warn("Session storage unavailable."); }
            }
        });
        try {
            const storedKey = sessionStorage.getItem('aiArenaApiKey');
            if (storedKey) {
                GEMINI_API_KEY = storedKey;
                apiKeyInput.value = storedKey;
            }
        } catch (e) { console.warn("Session storage unavailable.");}

        getApiKeyBtn.addEventListener('click', () => {
            window.open('https://aistudio.google.com/app/apikey', '_blank');
        });

        addCustomModelBtn.addEventListener('click', () => {
            const t = translations[currentLanguage];
            const modelName = customModelNameInput.value.trim();
            if (modelName && !availableModels.some(m => m.value === modelName)) {
                availableModels.push({ nameKey: modelName, value: modelName, isCustom: true }); // Store nameKey as modelName itself for custom
                updateAgentConfigUI(); // This will use currentLanguage to get the suffix
                customModelNameInput.value = '';
                logMessage(t.systemLogPrefix, t.logCustomModelAdded.replace("{modelName}", modelName), 'user-turn');
            } else if (!modelName) {
                alert(t.alertEnterModelName);
            } else {
                alert(t.alertModelExists.replace("{modelName}", modelName));
            }
        });

        startConversationBtn.addEventListener('click', () => {
            if (initializeConversation()) {
                checkRateLimitAndProceed(true);
            }
        });

        nextTurnBtn.addEventListener('click', () => {
            if (conversationActive && !autoNextTurnCheckbox.checked) {
                checkRateLimitAndProceed();
            }
        });

        stopConversationBtn.addEventListener('click', stopConversation);
        exportLogBtn.addEventListener('click', exportConversationLog);

        sendUserMessageBtn.addEventListener('click', () => {
            const t = translations[currentLanguage];
            const userMessage = userInjectMessageInput.value.trim();
            if (!userMessage || !conversationActive) return;
            logMessage(t.observerLogPrefix, userMessage, 'user-turn');
            userInjectMessageInput.value = '';
            checkRateLimitAndProceed(false, userMessage);
        });

        autoNextTurnCheckbox.addEventListener('change', () => {
            const t = translations[currentLanguage];
            if (conversationActive) {
                nextTurnBtn.disabled = autoNextTurnCheckbox.checked || loadingIndicator.style.display === 'block';
                if (autoNextTurnCheckbox.checked && 
                    loadingIndicator.style.display !== 'block' && 
                    currentTurn < currentMaxTurns &&
                    agents.length > 0) {
                    logMessage(t.systemLogPrefix, t.logAutoModeOn + ". " + t.logAutoRetryNextAi, 'user-turn');
                    checkRateLimitAndProceed(false, null);
                } else if (!autoNextTurnCheckbox.checked) {
                     logMessage(t.systemLogPrefix, t.logAutoModeOff + ". " + (translations[currentLanguage].nextTurnBtn) + " " + (translations[currentLanguage].userInjectMessageLabel.split(':')[0]), 'user-turn');
                }
            } else {
                nextTurnBtn.disabled = autoNextTurnCheckbox.checked;
            }
        });
        
        langEnBtn.addEventListener('click', () => setLanguage('en'));
        langZhBtn.addEventListener('click', () => setLanguage('zh'));

        // Initial UI setup
        try {
            const preferredLang = localStorage.getItem('aiArenaLanguage');
            if (preferredLang && translations[preferredLang]) {
                currentLanguage = preferredLang;
            }
        } catch(e) { console.warn("Local storage unavailable for loading language preference.");}
        
        setLanguage(currentLanguage); // Apply language an initial render

        if (!conversationLogDiv.hasChildNodes() || (conversationLogDiv.firstChild && conversationLogDiv.firstChild.id === 'conversationNotStarted')) {
             document.getElementById('conversationNotStarted').innerHTML = translations[currentLanguage].conversationNotStarted;
        }
    </script>
</body>
</html>
